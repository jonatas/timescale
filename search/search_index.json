{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The TimescaleDB Ruby Gem \u00b6 Welcome to the TimescaleDB gem! To experiment with the code, start installing the gem: Installing \u00b6 You can install the gem locally: gem install timescaledb Or require it directly in the Gemfile of your project: gem \"timescaledb\" Features \u00b6 The model can use the acts_as_hypertable macro. Check more on models documentation. The ActiveRecord migrations can use the create_table supporting the hypertable keyword. It's also enabling you to add retention and continuous aggregates policies A standalone create_hypertable macro is also allowed in the migrations. Testing also becomes easier as the schema dumper will automatically introduce the hypertables to all environments. It also contains a scenic extension to work with scenic views as it's a wide adoption in the community. The gem is also packed with a command line utility that makes it easier to navigate in your database with Pry and all your hypertables available in a Ruby style. Examples \u00b6 The all_in_one example shows: Create a hypertable with compression settings Insert data Run some queries Check chunk size per model Compress a chunk Check chunk status Decompress a chunk The ranking example shows how to configure a Rails app and navigate all the features available. Extra resources \u00b6 If you need extra help, please join the fantastic timescale community or ask your question on StackOverflow using the #timescaledb tag. If you want to go deeper in the library, the videos links to all live-coding sessions showed how @jonatasdp built the gem. Contributing \u00b6 Bug reports and pull requests are welcome on GitHub at https://github.com/jonatas/timescaledb. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the code of conduct . License \u00b6 The gem is available as open source under the MIT License . Code of Conduct \u00b6 Everyone interacting in the Timescale project's codebases, issue trackers, chat rooms, and mailing lists is expected to follow the code of conduct .","title":"Introduction"},{"location":"#the-timescaledb-ruby-gem","text":"Welcome to the TimescaleDB gem! To experiment with the code, start installing the gem:","title":"The TimescaleDB Ruby Gem"},{"location":"#installing","text":"You can install the gem locally: gem install timescaledb Or require it directly in the Gemfile of your project: gem \"timescaledb\"","title":"Installing"},{"location":"#features","text":"The model can use the acts_as_hypertable macro. Check more on models documentation. The ActiveRecord migrations can use the create_table supporting the hypertable keyword. It's also enabling you to add retention and continuous aggregates policies A standalone create_hypertable macro is also allowed in the migrations. Testing also becomes easier as the schema dumper will automatically introduce the hypertables to all environments. It also contains a scenic extension to work with scenic views as it's a wide adoption in the community. The gem is also packed with a command line utility that makes it easier to navigate in your database with Pry and all your hypertables available in a Ruby style.","title":"Features"},{"location":"#examples","text":"The all_in_one example shows: Create a hypertable with compression settings Insert data Run some queries Check chunk size per model Compress a chunk Check chunk status Decompress a chunk The ranking example shows how to configure a Rails app and navigate all the features available.","title":"Examples"},{"location":"#extra-resources","text":"If you need extra help, please join the fantastic timescale community or ask your question on StackOverflow using the #timescaledb tag. If you want to go deeper in the library, the videos links to all live-coding sessions showed how @jonatasdp built the gem.","title":"Extra resources"},{"location":"#contributing","text":"Bug reports and pull requests are welcome on GitHub at https://github.com/jonatas/timescaledb. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the code of conduct .","title":"Contributing"},{"location":"#license","text":"The gem is available as open source under the MIT License .","title":"License"},{"location":"#code-of-conduct","text":"Everyone interacting in the Timescale project's codebases, issue trackers, chat rooms, and mailing lists is expected to follow the code of conduct .","title":"Code of Conduct"},{"location":"command_line/","text":"Command line application \u00b6 When you install the gem locally, a new command line application named tsdb will be available on your command line. The tsdb CLI \u00b6 It accepts a Postgresql URI and some extra flags that can help you to get more info from your TimescaleDB server: tsdb <uri> --stats Where the <uri> is replaced with params from your connection like: tsdb postgres://<user>@localhost:5432/<dbname> --stats Or merely check the stats: tsdb \"postgres://<user>@localhost:5432/timescaledb_test\" --stats Here is a sample output from a database example with almost no data: { :hypertables => { :count => 3 , :uncompressed => 2 , :chunks => { :total => 1 , :compressed => 0 , :uncompressed => 1 }, :size => { :befoe_compressing => \"80 KB\" , :after_compressing => \"0 Bytes\" }}, :continuous_aggregates => { :count => 1 }, :jobs_stats =>[ { :success => nil , :runs => nil , :failures => nil } ] } To start a interactive ruby/ pry console use --console : The console will dynamically create models for all hypertables that it finds in the database. Let's consider the caggs.sql as the example of a database. psql postgres://<user>@localhost:5432/playground -f caggs.sql Then use tsdb in the command line with the same URI and --stats : tsdb postgres : // < user > @localhost : 5432 / playground -- stats { :hypertables => { :count => 1 , :uncompressed => 1 , :approximate_row_count => { \"ticks\" => 352 }, :chunks => { :total => 1 , :compressed => 0 , :uncompressed => 1 }, :size => { :uncompressed => \"88 KB\" , :compressed => \"0 Bytes\" }}, :continuous_aggregates => { :total => 1 }, :jobs_stats =>[ { :success => nil , :runs => nil , :failures => nil } ] } To have some interactive playground with the actual database using ruby, just try the same command before changing from --stats to --console : tsdb --console \u00b6 We are using the same database from the previous example for this context which contains a hypertable named ticks and a view called ohlc_1m . tsdb postgres : // < user > @localhost : 5432 / playground -- console pry ( Timescale ) > The tsdb CLI will automatically create ActiveRecord models for hypertables and the continuous aggregates views. Tick => Timescaledb :: Tick ( time : datetime , symbol : string , price : decimal , volume : integer ) Note that it's only created for this session and will never cache in the library or any other place. In this case, the Tick model comes from the ticks hypertable found in the database. It contains several methods inherited from the acts_as_hypertable macro. Let's start with the .hypertable method. Tick . hypertable => #<Timescaledb::Hypertable:0x00007fe99c258900 hypertable_schema : \"public\" , hypertable_name : \"ticks\" , owner : \"jonatasdp\" , num_dimensions : 1 , num_chunks : 1 , compression_enabled : false , is_distributed : false , replication_factor : nil , data_nodes : nil , tablespaces : nil > The core of the hypertables is the fragmentation of the data into chunks, the child tables that distribute the data. You can check all chunks directly from the hypertable relation. Tick . hypertable . chunks unknown OID 2206 : failed to recognize type of 'primary_dimension_type' . It will cast as a String . => [ #<Timescaledb::Chunk:0x00007fe99c31b068 hypertable_schema : \"public\" , hypertable_name : \"ticks\" , chunk_schema : \"_timescaledb_internal\" , chunk_name : \"_hyper_33_17_chunk\" , primary_dimension : \"time\" , primary_dimension_type : \"timestamp without time zone\" , range_start : 1999 - 12 - 30 00 : 00 : 00 + 0000 , range_end : 2000 - 01 - 06 00 : 00 : 00 + 0000 , range_start_integer : nil , range_end_integer : nil , is_compressed : false , chunk_tablespace : nil , data_nodes : nil >] Chunks are created by partitioning the hypertable data into one (or potentially multiple) dimensions. All hypertables are partitions by the values belonging to a time column, which may be in timestamp, date, or various integer forms. If the time partitioning interval is one day, for example, then rows with timestamps that belong to the same day are co-located within the same chunk, while rows belonging to different days belong to different chunks. Learn more here . Another core concept of TimescaleDB is compression. With data partitioned, it becomes very convenient to compress and decompress chunks independently. Tick . hypertable . chunks . first . compress! ActiveRecord :: StatementInvalid : PG :: FeatureNotSupported : ERROR : compression not enabled on \"ticks\" DETAIL : It is not possible to compress chunks on a hypertable that does not have compression enabled . HINT : Enable compression using ALTER TABLE with the timescaledb . compress option . As compression is not enabled, let's do it by executing plain SQL directly from the actual context. To borrow a connection, let's use the Tick object. Tick . connection . execute ( \"ALTER TABLE ticks SET (timescaledb.compress)\" ) # => PG_OK And now, it's possible to compress and decompress: Tick . hypertable . chunks . first . compress! Tick . hypertable . chunks . first . decompress! Learn more about TimescaleDB compression here . The ohlc_1m view is also available as an ActiveRecord: Ohlc1m => Timescaledb :: Ohlc1m ( bucket : datetime , symbol : string , open : decimal , high : decimal , low : decimal , close : decimal , volume : integer ) And you can run any query as you do with regular active record queries. Ohlc1m . order ( bucket : :desc ) . last => #<Timescaledb::Ohlc1m:0x00007fe99c2c38e0 bucket : 2000 - 01 - 01 00 : 00 : 00 UTC , symbol : \"SYMBOL\" , open : 0 . 13 e2 , high : 0 . 3 e2 , low : 0 . 1 e1 , close : 0 . 1 e2 , volume : 27600 >","title":"Command Line"},{"location":"command_line/#command-line-application","text":"When you install the gem locally, a new command line application named tsdb will be available on your command line.","title":"Command line application"},{"location":"command_line/#the-tsdb-cli","text":"It accepts a Postgresql URI and some extra flags that can help you to get more info from your TimescaleDB server: tsdb <uri> --stats Where the <uri> is replaced with params from your connection like: tsdb postgres://<user>@localhost:5432/<dbname> --stats Or merely check the stats: tsdb \"postgres://<user>@localhost:5432/timescaledb_test\" --stats Here is a sample output from a database example with almost no data: { :hypertables => { :count => 3 , :uncompressed => 2 , :chunks => { :total => 1 , :compressed => 0 , :uncompressed => 1 }, :size => { :befoe_compressing => \"80 KB\" , :after_compressing => \"0 Bytes\" }}, :continuous_aggregates => { :count => 1 }, :jobs_stats =>[ { :success => nil , :runs => nil , :failures => nil } ] } To start a interactive ruby/ pry console use --console : The console will dynamically create models for all hypertables that it finds in the database. Let's consider the caggs.sql as the example of a database. psql postgres://<user>@localhost:5432/playground -f caggs.sql Then use tsdb in the command line with the same URI and --stats : tsdb postgres : // < user > @localhost : 5432 / playground -- stats { :hypertables => { :count => 1 , :uncompressed => 1 , :approximate_row_count => { \"ticks\" => 352 }, :chunks => { :total => 1 , :compressed => 0 , :uncompressed => 1 }, :size => { :uncompressed => \"88 KB\" , :compressed => \"0 Bytes\" }}, :continuous_aggregates => { :total => 1 }, :jobs_stats =>[ { :success => nil , :runs => nil , :failures => nil } ] } To have some interactive playground with the actual database using ruby, just try the same command before changing from --stats to --console :","title":"The tsdb CLI"},{"location":"command_line/#tsdb-console","text":"We are using the same database from the previous example for this context which contains a hypertable named ticks and a view called ohlc_1m . tsdb postgres : // < user > @localhost : 5432 / playground -- console pry ( Timescale ) > The tsdb CLI will automatically create ActiveRecord models for hypertables and the continuous aggregates views. Tick => Timescaledb :: Tick ( time : datetime , symbol : string , price : decimal , volume : integer ) Note that it's only created for this session and will never cache in the library or any other place. In this case, the Tick model comes from the ticks hypertable found in the database. It contains several methods inherited from the acts_as_hypertable macro. Let's start with the .hypertable method. Tick . hypertable => #<Timescaledb::Hypertable:0x00007fe99c258900 hypertable_schema : \"public\" , hypertable_name : \"ticks\" , owner : \"jonatasdp\" , num_dimensions : 1 , num_chunks : 1 , compression_enabled : false , is_distributed : false , replication_factor : nil , data_nodes : nil , tablespaces : nil > The core of the hypertables is the fragmentation of the data into chunks, the child tables that distribute the data. You can check all chunks directly from the hypertable relation. Tick . hypertable . chunks unknown OID 2206 : failed to recognize type of 'primary_dimension_type' . It will cast as a String . => [ #<Timescaledb::Chunk:0x00007fe99c31b068 hypertable_schema : \"public\" , hypertable_name : \"ticks\" , chunk_schema : \"_timescaledb_internal\" , chunk_name : \"_hyper_33_17_chunk\" , primary_dimension : \"time\" , primary_dimension_type : \"timestamp without time zone\" , range_start : 1999 - 12 - 30 00 : 00 : 00 + 0000 , range_end : 2000 - 01 - 06 00 : 00 : 00 + 0000 , range_start_integer : nil , range_end_integer : nil , is_compressed : false , chunk_tablespace : nil , data_nodes : nil >] Chunks are created by partitioning the hypertable data into one (or potentially multiple) dimensions. All hypertables are partitions by the values belonging to a time column, which may be in timestamp, date, or various integer forms. If the time partitioning interval is one day, for example, then rows with timestamps that belong to the same day are co-located within the same chunk, while rows belonging to different days belong to different chunks. Learn more here . Another core concept of TimescaleDB is compression. With data partitioned, it becomes very convenient to compress and decompress chunks independently. Tick . hypertable . chunks . first . compress! ActiveRecord :: StatementInvalid : PG :: FeatureNotSupported : ERROR : compression not enabled on \"ticks\" DETAIL : It is not possible to compress chunks on a hypertable that does not have compression enabled . HINT : Enable compression using ALTER TABLE with the timescaledb . compress option . As compression is not enabled, let's do it by executing plain SQL directly from the actual context. To borrow a connection, let's use the Tick object. Tick . connection . execute ( \"ALTER TABLE ticks SET (timescaledb.compress)\" ) # => PG_OK And now, it's possible to compress and decompress: Tick . hypertable . chunks . first . compress! Tick . hypertable . chunks . first . decompress! Learn more about TimescaleDB compression here . The ohlc_1m view is also available as an ActiveRecord: Ohlc1m => Timescaledb :: Ohlc1m ( bucket : datetime , symbol : string , open : decimal , high : decimal , low : decimal , close : decimal , volume : integer ) And you can run any query as you do with regular active record queries. Ohlc1m . order ( bucket : :desc ) . last => #<Timescaledb::Ohlc1m:0x00007fe99c2c38e0 bucket : 2000 - 01 - 01 00 : 00 : 00 UTC , symbol : \"SYMBOL\" , open : 0 . 13 e2 , high : 0 . 3 e2 , low : 0 . 1 e1 , close : 0 . 1 e2 , volume : 27600 >","title":"tsdb --console"},{"location":"migrations/","text":"ActiveRecord migrations helpers for Timescale \u00b6 Create table is now with the hypertable keyword allowing to pass a few options to the function call while also using the create_table method: create_table with the :hypertable option \u00b6 hypertable_options = { time_column : 'created_at' , chunk_time_interval : '1 min' , compress_segmentby : 'identifier' , compression_interval : '7 days' } create_table ( :events , id : false , hypertable : hypertable_options ) do | t | t . string :identifier , null : false t . jsonb :payload t . timestamps end The create_continuous_aggregate helper \u00b6 This example shows a ticks table grouping ticks as OHLCV histograms for every minute. hypertable_options = { time_column : 'created_at' , chunk_time_interval : '1 min' , compress_segmentby : 'symbol' , compress_orderby : 'created_at' , compression_interval : '7 days' } create_table :ticks , hypertable : hypertable_options , id : false do | t | t . string :symbol t . decimal :price t . integer :volume t . timestamps end Tick = Class . new ( ActiveRecord :: Base ) do self . table_name = 'ticks' self . primary_key = 'symbol' acts_as_hypertable end query = Tick . select ( <<~ QUERY ) time_bucket('1m', created_at) as time, symbol, FIRST(price, created_at) as open, MAX(price) as high, MIN(price) as low, LAST(price, created_at) as close, SUM(volume) as volume\").group(\"1,2\") QUERY options = { with_data : false , refresh_policies : { start_offset : \"INTERVAL '1 month'\" , end_offset : \"INTERVAL '1 minute'\" , schedule_interval : \"INTERVAL '1 minute'\" } } create_continuous_aggregate ( 'ohlc_1m' , query , ** options )","title":"Migrations"},{"location":"migrations/#activerecord-migrations-helpers-for-timescale","text":"Create table is now with the hypertable keyword allowing to pass a few options to the function call while also using the create_table method:","title":"ActiveRecord migrations helpers for Timescale"},{"location":"migrations/#create_table-with-the-hypertable-option","text":"hypertable_options = { time_column : 'created_at' , chunk_time_interval : '1 min' , compress_segmentby : 'identifier' , compression_interval : '7 days' } create_table ( :events , id : false , hypertable : hypertable_options ) do | t | t . string :identifier , null : false t . jsonb :payload t . timestamps end","title":"create_table with the :hypertable option"},{"location":"migrations/#the-create_continuous_aggregate-helper","text":"This example shows a ticks table grouping ticks as OHLCV histograms for every minute. hypertable_options = { time_column : 'created_at' , chunk_time_interval : '1 min' , compress_segmentby : 'symbol' , compress_orderby : 'created_at' , compression_interval : '7 days' } create_table :ticks , hypertable : hypertable_options , id : false do | t | t . string :symbol t . decimal :price t . integer :volume t . timestamps end Tick = Class . new ( ActiveRecord :: Base ) do self . table_name = 'ticks' self . primary_key = 'symbol' acts_as_hypertable end query = Tick . select ( <<~ QUERY ) time_bucket('1m', created_at) as time, symbol, FIRST(price, created_at) as open, MAX(price) as high, MIN(price) as low, LAST(price, created_at) as close, SUM(volume) as volume\").group(\"1,2\") QUERY options = { with_data : false , refresh_policies : { start_offset : \"INTERVAL '1 month'\" , end_offset : \"INTERVAL '1 minute'\" , schedule_interval : \"INTERVAL '1 minute'\" } } create_continuous_aggregate ( 'ohlc_1m' , query , ** options )","title":"The create_continuous_aggregate helper"},{"location":"models/","text":"Models \u00b6 The ActiveRecord is the default ORM in the Ruby community. We have introduced a macro that helps you to inject the behavior as other libraries do in the Rails ecosystem. The acts_as_hypertable macro \u00b6 You can declare a Rails model as a Hypertable by invoking the acts_as_hypertable macro. This macro extends your existing model with timescaledb-related functionality. model: class Event < ActiveRecord :: Base acts_as_hypertable end By default, ActsAsHypertable assumes a record's time_column is called created_at . Options \u00b6 If you are using a different time_column name, you can specify it as follows when invoking the acts_as_hypertable macro: class Event < ActiveRecord :: Base acts_as_hypertable time_column :timestamp end Chunks \u00b6 To get all the chunks from a model's hypertable, you can use .chunks . Event . chunks # => [#<Timescaledb::Chunk>, ...] Hypertable metadata \u00b6 To get the models' hypertable metadata, you can use .hypertable . Event . hypertable # => #<Timescaledb::Hypertable> To get hypertable metadata for all hypertables: Timescaledb.hypertables . Compression Settings \u00b6 Compression settings are accessible through the hypertable. Event . hypertable . compression_settings # => [#<Timescaledb::CompressionSettings>, ...] To get compression settings for all hypertables: Timescaledb.compression_settings . Scopes \u00b6 When you enable ActsAsHypertable on your model, we include a few default scopes. They are: Scope name What they return Model.previous_month Records created in the previous month Model.previous_week Records created in the previous week Model.this_month Records created this month Model.this_week Records created this week Model.yesterday Records created yesterday Model.today Records created today Model.last_hour Records created in the last hour All time-related scopes respect your application's timezone. Scenic integration \u00b6 The Scenic gem is easy to manage database view definitions for a Rails application. Unfortunately, TimescaleDB's continuous aggregates are more complex than regular PostgreSQL views, and the schema dumper included with Scenic can't dump a complete definition. This gem automatically configures Scenic to use a Timescaledb::Scenic::Adapter. which will correctly handle schema dumping.","title":"Models"},{"location":"models/#models","text":"The ActiveRecord is the default ORM in the Ruby community. We have introduced a macro that helps you to inject the behavior as other libraries do in the Rails ecosystem.","title":"Models"},{"location":"models/#the-acts_as_hypertable-macro","text":"You can declare a Rails model as a Hypertable by invoking the acts_as_hypertable macro. This macro extends your existing model with timescaledb-related functionality. model: class Event < ActiveRecord :: Base acts_as_hypertable end By default, ActsAsHypertable assumes a record's time_column is called created_at .","title":"The acts_as_hypertable macro"},{"location":"models/#options","text":"If you are using a different time_column name, you can specify it as follows when invoking the acts_as_hypertable macro: class Event < ActiveRecord :: Base acts_as_hypertable time_column :timestamp end","title":"Options"},{"location":"models/#chunks","text":"To get all the chunks from a model's hypertable, you can use .chunks . Event . chunks # => [#<Timescaledb::Chunk>, ...]","title":"Chunks"},{"location":"models/#hypertable-metadata","text":"To get the models' hypertable metadata, you can use .hypertable . Event . hypertable # => #<Timescaledb::Hypertable> To get hypertable metadata for all hypertables: Timescaledb.hypertables .","title":"Hypertable metadata"},{"location":"models/#compression-settings","text":"Compression settings are accessible through the hypertable. Event . hypertable . compression_settings # => [#<Timescaledb::CompressionSettings>, ...] To get compression settings for all hypertables: Timescaledb.compression_settings .","title":"Compression Settings"},{"location":"models/#scopes","text":"When you enable ActsAsHypertable on your model, we include a few default scopes. They are: Scope name What they return Model.previous_month Records created in the previous month Model.previous_week Records created in the previous week Model.this_month Records created this month Model.this_week Records created this week Model.yesterday Records created yesterday Model.today Records created today Model.last_hour Records created in the last hour All time-related scopes respect your application's timezone.","title":"Scopes"},{"location":"models/#scenic-integration","text":"The Scenic gem is easy to manage database view definitions for a Rails application. Unfortunately, TimescaleDB's continuous aggregates are more complex than regular PostgreSQL views, and the schema dumper included with Scenic can't dump a complete definition. This gem automatically configures Scenic to use a Timescaledb::Scenic::Adapter. which will correctly handle schema dumping.","title":"Scenic integration"},{"location":"toolkit/","text":"The TimescaleDB Toolkit \u00b6 The TimescaleDB Toolkit is an extension brought by Timescale for more hyperfunctions, fully compatible with TimescaleDB and PostgreSQL. They have almost no dependecy of hypertables but they play very well in the hypertables ecosystem. The mission of the toolkit team is to ease all things analytics when using TimescaleDB, with a particular focus on developer ergonomics and performance. Here, we're going to have a small walkthrough in some of the toolkit functions and the helpers that can make simplify the generation of some complex queries. Warning Note that we're just starting the toolkit integration in the gem and several functions are still experimental. The add_toolkit_to_search_path! helper \u00b6 Several functions on the toolkit are still in experimental phase, and for that reason they're not in the public schema, but lives in the toolkit_experimental schema. To use them without worring about the schema or prefixing it in all the cases, you can introduce the schema as part of the search_path . To make it easy in the Ruby side, you can call the method directly from the ActiveRecord connection: ActiveRecord :: Base . connection . add_toolkit_to_search_path! This statement is actually adding the toolkit_experimental to the search path aside of the public and the $user variable path. The statement can be placed right before your usage of the toolkit. For example, if a single controller in your Rails app will be using it, you can create a filter in the controller to set up it before the use of your action. class StatisticsController < ActionController :: Base before_action :add_timescale_toolkit , only : [ :complex_query ] def complex_query # some code that uses the toolkit functions end protected def add_timescale_toolkit ActiveRecord :: Base . connection . add_toolkit_to_search_path! end Example from scratch to use the Toolkit functions \u00b6 Let's start by working on some example about the volatility algorithm. This example is inspired in the function pipelines blog post, which brings an example about how to calculate volatility and then apply the function pipelines to make the same with the toolkit. Success Reading the blog post before trying this is highly recommended, and will give you more insights on how to apply and use time vectors that is our next topic. Let's start by creating the measurements hypertable using a regular migration: class CreateMeasurements < ActiveRecord :: Migration def change hypertable_options = { time_column : 'ts' , chunk_time_interval : '1 day' , } create_table :measurements , hypertable : hypertable_options , id : false do | t | t . integer :device_id t . decimal :val t . timestamp :ts end end end In this example, we just have a hypertable with no compression options. Every 1 day a new child table aka chunk will be generated. No compression options for now. Now, let's add the model app/models/measurement.rb : class Measurement < ActiveRecord :: Base do self . primary_key = 'device_id' acts_as_hypertable time_column : \"ts\" end At this moment, you can jump into the Rails console and start testing the model. Seeding some data \u00b6 Before we build a very complex example, let's build something that is easy to follow and comprehend. Let's create 3 records for the same device, representing a hourly measurement of some sensor. yesterday = 1 . day . ago [ 1 , 2 , 3 ]. each_with_index do | v , i | Measurement . create ( device_id : 1 , ts : yesterday + i . hour , val : v ) end Every value is a progression from 1 to 3. Now, we can build a query to get the values and let's build the example using plain Ruby. values = Measurement . order ( :ts ) . pluck ( :val ) # => [1,2,3] Using plain Ruby, we can build this example with a few lines of code: previous = nil volatilities = values . map do | value | if previous delta = ( value - previous ) . abs volatility = delta end previous = value volatility end # volatilities => [nil, 1, 1] volatility = volatilities . compact . sum # => 2 Compact can be skipped and we can also build the sum in the same loop. So, a refactored version would be: previous = nil volatility = 0 values . each do | value | if previous delta = ( value - previous ) . abs volatility += delta end previous = value end volatility # => 2 Now, it's time to move it to a database level calculating the volatility using plain postgresql. A subquery is required to build the calculated delta, so it seems a bit more confusing: delta = Measurement . select ( \"device_id, abs(val - lag(val) OVER (PARTITION BY device_id ORDER BY ts)) as abs_delta\" ) Measurement . select ( \"device_id, sum(abs_delta) as volatility\" ) . from ( \"( #{ delta . to_sql } ) as calc_delta\" ) . group ( 'device_id' ) The final query for the example above looks like this: SELECT device_id , sum ( abs_delta ) as volatility FROM ( SELECT device_id , abs ( val - lag ( val ) OVER ( PARTITION BY device_id ORDER BY ts )) as abs_delta FROM \"measurements\" ) as calc_delta GROUP BY device_id It's much harder to understand the actual example then go with plain SQL and now let's reproduce the same example using the toolkit pipelines: Measurement . select ( \"device_id, timevector(ts, val) -> sort() -> delta() -> abs() -> sum() as volatility\" ) . group ( \"device_id\" ) As you can see, it's much easier to read and digest the example. Now, let's take a look in how we can generate the queries using the scopes injected by the acts_as_time_vector macro. Adding the acts_as_time_vector macro \u00b6 Let's start changing the model to add the acts_as_time_vector that is here to allow us to not repeat the parameters of the timevector(ts, val) call. class Measurement < ActiveRecord :: Base do self . primary_key = 'device_id' acts_as_hypertable time_column : \"ts\" acts_as_time_vector segment_by : \"device_id\" , value_column : \"val\" , time_column : \"ts\" end end If you skip the time_column option in the acts_as_time_vector it will inherit the same value from the acts_as_hypertable . I'm making it explicit here for the sake of making the macros independent. Now, that we have it, let's create a scope for it: class Measurement < ActiveRecord :: Base do # ... Skipping previous code to focus in the example acts_as_time_vector segment_by : \"device_id\" , value_column : \"val\" , time_column : \"ts\" end scope :volatility , -> do select ( \"device_id, timevector( #{ time_column } , #{ value_column } ) -> sort() -> delta() -> abs() -> sum() as volatility\" ) . group ( \"device_id\" ) end end Now, we have created the volatility scope, grouping by device_id always. In the Toolkit helpers, we have a similar version which also contains a default segmentation based in the segment_by configuration done through the acts_as_time_vector macro. A method segment_by_column is added to access this configuration, so we can make a small change that makes you completely understand the volatility macro. class Measurement < ActiveRecord :: Base do # ... Skipping previous code to focus in the example acts_as_time_vector segment_by : \"device_id\" , value_column : \"val\" , time_column : \"ts\" end scope :volatility , -> ( columns = segment_by_column ) do select ( [* columns , \"timevector( #{ time_column } , #{ value_column } ) -> sort() -> delta() -> abs() -> sum() as volatility\" ]. join ( \", \" )) _scope = _scope . group ( columns ) if columns _scope end end Testing the method: Measurement . volatility . map ( & :attributes ) # D, [2022-08-11T10:18:05.932687 #10885] DEBUG -- : Measurement Load (1.6ms) SELECT device_id, timevector(ts, val) -> sort() -> delta() -> abs() -> sum() as volatility FROM \"measurements\" GROUP BY \"measurements\".\"device_id\" # => [{\"device_id\"=>1, \"volatility\"=>8.0}] Let's add a few more records with random values: yesterday = 1 . day . ago ( 2 .. 6 ) . each do | d | ( 1 .. 10 ) . each do | j | Measurement . create ( device_id : d , ts : yesterday + j . hour , val : rand ( 10 )) end end Testing all the values: Measurement . order ( \"device_id\" ) . volatility . map ( & :attributes ) D , [ 2022 - 08 - 11 T10 : 45 : 54 . 174458 #10885] DEBUG -- : Measurement Load (1.3ms) SELECT device_id, timevector(ts, val) -> sort() -> delta() -> abs() -> sum() as volatility FROM \"measurements\" GROUP BY \"measurements\".\"device_id\" ORDER BY device_id => [ { \"device_id\" => 1 , \"volatility\" => 8 . 0 }, { \"device_id\" => 2 , \"volatility\" => 24 . 0 }, { \"device_id\" => 3 , \"volatility\" => 30 . 0 }, { \"device_id\" => 4 , \"volatility\" => 32 . 0 }, { \"device_id\" => 5 , \"volatility\" => 44 . 0 }, { \"device_id\" => 6 , \"volatility\" => 23 . 0 } ]","title":"Toolkit Integration"},{"location":"toolkit/#the-timescaledb-toolkit","text":"The TimescaleDB Toolkit is an extension brought by Timescale for more hyperfunctions, fully compatible with TimescaleDB and PostgreSQL. They have almost no dependecy of hypertables but they play very well in the hypertables ecosystem. The mission of the toolkit team is to ease all things analytics when using TimescaleDB, with a particular focus on developer ergonomics and performance. Here, we're going to have a small walkthrough in some of the toolkit functions and the helpers that can make simplify the generation of some complex queries. Warning Note that we're just starting the toolkit integration in the gem and several functions are still experimental.","title":"The TimescaleDB Toolkit"},{"location":"toolkit/#the-add_toolkit_to_search_path-helper","text":"Several functions on the toolkit are still in experimental phase, and for that reason they're not in the public schema, but lives in the toolkit_experimental schema. To use them without worring about the schema or prefixing it in all the cases, you can introduce the schema as part of the search_path . To make it easy in the Ruby side, you can call the method directly from the ActiveRecord connection: ActiveRecord :: Base . connection . add_toolkit_to_search_path! This statement is actually adding the toolkit_experimental to the search path aside of the public and the $user variable path. The statement can be placed right before your usage of the toolkit. For example, if a single controller in your Rails app will be using it, you can create a filter in the controller to set up it before the use of your action. class StatisticsController < ActionController :: Base before_action :add_timescale_toolkit , only : [ :complex_query ] def complex_query # some code that uses the toolkit functions end protected def add_timescale_toolkit ActiveRecord :: Base . connection . add_toolkit_to_search_path! end","title":"The add_toolkit_to_search_path! helper"},{"location":"toolkit/#example-from-scratch-to-use-the-toolkit-functions","text":"Let's start by working on some example about the volatility algorithm. This example is inspired in the function pipelines blog post, which brings an example about how to calculate volatility and then apply the function pipelines to make the same with the toolkit. Success Reading the blog post before trying this is highly recommended, and will give you more insights on how to apply and use time vectors that is our next topic. Let's start by creating the measurements hypertable using a regular migration: class CreateMeasurements < ActiveRecord :: Migration def change hypertable_options = { time_column : 'ts' , chunk_time_interval : '1 day' , } create_table :measurements , hypertable : hypertable_options , id : false do | t | t . integer :device_id t . decimal :val t . timestamp :ts end end end In this example, we just have a hypertable with no compression options. Every 1 day a new child table aka chunk will be generated. No compression options for now. Now, let's add the model app/models/measurement.rb : class Measurement < ActiveRecord :: Base do self . primary_key = 'device_id' acts_as_hypertable time_column : \"ts\" end At this moment, you can jump into the Rails console and start testing the model.","title":"Example from scratch to use the Toolkit functions"},{"location":"toolkit/#seeding-some-data","text":"Before we build a very complex example, let's build something that is easy to follow and comprehend. Let's create 3 records for the same device, representing a hourly measurement of some sensor. yesterday = 1 . day . ago [ 1 , 2 , 3 ]. each_with_index do | v , i | Measurement . create ( device_id : 1 , ts : yesterday + i . hour , val : v ) end Every value is a progression from 1 to 3. Now, we can build a query to get the values and let's build the example using plain Ruby. values = Measurement . order ( :ts ) . pluck ( :val ) # => [1,2,3] Using plain Ruby, we can build this example with a few lines of code: previous = nil volatilities = values . map do | value | if previous delta = ( value - previous ) . abs volatility = delta end previous = value volatility end # volatilities => [nil, 1, 1] volatility = volatilities . compact . sum # => 2 Compact can be skipped and we can also build the sum in the same loop. So, a refactored version would be: previous = nil volatility = 0 values . each do | value | if previous delta = ( value - previous ) . abs volatility += delta end previous = value end volatility # => 2 Now, it's time to move it to a database level calculating the volatility using plain postgresql. A subquery is required to build the calculated delta, so it seems a bit more confusing: delta = Measurement . select ( \"device_id, abs(val - lag(val) OVER (PARTITION BY device_id ORDER BY ts)) as abs_delta\" ) Measurement . select ( \"device_id, sum(abs_delta) as volatility\" ) . from ( \"( #{ delta . to_sql } ) as calc_delta\" ) . group ( 'device_id' ) The final query for the example above looks like this: SELECT device_id , sum ( abs_delta ) as volatility FROM ( SELECT device_id , abs ( val - lag ( val ) OVER ( PARTITION BY device_id ORDER BY ts )) as abs_delta FROM \"measurements\" ) as calc_delta GROUP BY device_id It's much harder to understand the actual example then go with plain SQL and now let's reproduce the same example using the toolkit pipelines: Measurement . select ( \"device_id, timevector(ts, val) -> sort() -> delta() -> abs() -> sum() as volatility\" ) . group ( \"device_id\" ) As you can see, it's much easier to read and digest the example. Now, let's take a look in how we can generate the queries using the scopes injected by the acts_as_time_vector macro.","title":"Seeding some data"},{"location":"toolkit/#adding-the-acts_as_time_vector-macro","text":"Let's start changing the model to add the acts_as_time_vector that is here to allow us to not repeat the parameters of the timevector(ts, val) call. class Measurement < ActiveRecord :: Base do self . primary_key = 'device_id' acts_as_hypertable time_column : \"ts\" acts_as_time_vector segment_by : \"device_id\" , value_column : \"val\" , time_column : \"ts\" end end If you skip the time_column option in the acts_as_time_vector it will inherit the same value from the acts_as_hypertable . I'm making it explicit here for the sake of making the macros independent. Now, that we have it, let's create a scope for it: class Measurement < ActiveRecord :: Base do # ... Skipping previous code to focus in the example acts_as_time_vector segment_by : \"device_id\" , value_column : \"val\" , time_column : \"ts\" end scope :volatility , -> do select ( \"device_id, timevector( #{ time_column } , #{ value_column } ) -> sort() -> delta() -> abs() -> sum() as volatility\" ) . group ( \"device_id\" ) end end Now, we have created the volatility scope, grouping by device_id always. In the Toolkit helpers, we have a similar version which also contains a default segmentation based in the segment_by configuration done through the acts_as_time_vector macro. A method segment_by_column is added to access this configuration, so we can make a small change that makes you completely understand the volatility macro. class Measurement < ActiveRecord :: Base do # ... Skipping previous code to focus in the example acts_as_time_vector segment_by : \"device_id\" , value_column : \"val\" , time_column : \"ts\" end scope :volatility , -> ( columns = segment_by_column ) do select ( [* columns , \"timevector( #{ time_column } , #{ value_column } ) -> sort() -> delta() -> abs() -> sum() as volatility\" ]. join ( \", \" )) _scope = _scope . group ( columns ) if columns _scope end end Testing the method: Measurement . volatility . map ( & :attributes ) # D, [2022-08-11T10:18:05.932687 #10885] DEBUG -- : Measurement Load (1.6ms) SELECT device_id, timevector(ts, val) -> sort() -> delta() -> abs() -> sum() as volatility FROM \"measurements\" GROUP BY \"measurements\".\"device_id\" # => [{\"device_id\"=>1, \"volatility\"=>8.0}] Let's add a few more records with random values: yesterday = 1 . day . ago ( 2 .. 6 ) . each do | d | ( 1 .. 10 ) . each do | j | Measurement . create ( device_id : d , ts : yesterday + j . hour , val : rand ( 10 )) end end Testing all the values: Measurement . order ( \"device_id\" ) . volatility . map ( & :attributes ) D , [ 2022 - 08 - 11 T10 : 45 : 54 . 174458 #10885] DEBUG -- : Measurement Load (1.3ms) SELECT device_id, timevector(ts, val) -> sort() -> delta() -> abs() -> sum() as volatility FROM \"measurements\" GROUP BY \"measurements\".\"device_id\" ORDER BY device_id => [ { \"device_id\" => 1 , \"volatility\" => 8 . 0 }, { \"device_id\" => 2 , \"volatility\" => 24 . 0 }, { \"device_id\" => 3 , \"volatility\" => 30 . 0 }, { \"device_id\" => 4 , \"volatility\" => 32 . 0 }, { \"device_id\" => 5 , \"volatility\" => 44 . 0 }, { \"device_id\" => 6 , \"volatility\" => 23 . 0 } ]","title":"Adding the acts_as_time_vector macro"},{"location":"videos/","text":"Videos about the TimescaleDB Gem \u00b6 This library was started on twitch.tv/timescaledb . You can watch all episodes here: Wrapping Functions to Ruby Helpers . Extending ActiveRecord with Timescale Helpers . Setup Hypertables for Rails testing environment . Packing the code to this repository . the code to this repository . Working with Timescale continuous aggregates . Creating the command-line application in Ruby to explore the Timescale API . If you create any content related to how to use the Timescale Gem, please open a Pull Request .","title":"Videos"},{"location":"videos/#videos-about-the-timescaledb-gem","text":"This library was started on twitch.tv/timescaledb . You can watch all episodes here: Wrapping Functions to Ruby Helpers . Extending ActiveRecord with Timescale Helpers . Setup Hypertables for Rails testing environment . Packing the code to this repository . the code to this repository . Working with Timescale continuous aggregates . Creating the command-line application in Ruby to explore the Timescale API . If you create any content related to how to use the Timescale Gem, please open a Pull Request .","title":"Videos about the TimescaleDB Gem"}]}